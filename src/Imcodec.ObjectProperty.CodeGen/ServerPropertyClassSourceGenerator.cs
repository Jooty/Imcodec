/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Imcodec.ObjectProperty.CodeGen.Definitions;

namespace Imcodec.ObjectProperty.CodeGen {

    [Generator]
    public sealed class ServerPropertyClassSourceGenerator : IIncrementalGenerator {
        
        private const string CopyrightHeader = @"/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/";

        private const string ContainingNamespace = "Imcodec.ObjectProperty.TypeCache";
        private const string TypeRegistryClassName = "ServerGeneratedTypeRegistry";
        private static readonly string s_autoGeneratedWarning = $"// <auto-generated"
            + $" by {typeof(ServerPropertyClassSourceGenerator).Assembly.GetName().Name}>";

        private const string PropertyClassAttributeName = "PropertySerializationTarget";
        private const string AutoPropertyAttributeName = "PropertyField";

        public void Initialize(IncrementalGeneratorInitializationContext context) {
            // Get all class declarations with our target attribute (PropertySerializationTargetAttribute).
            var typeDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsCandidateClass(s),
                    transform: static (ctx, _) => ctx.Node as TypeDeclarationSyntax)
                .Where(type => type is not null)
                .Select((type, _) => type!)
                .Where(type => HasAttribute(type, PropertyClassAttributeName));

            // Register source output.
            IncrementalValueProvider<(Compilation, ImmutableArray<TypeDeclarationSyntax>)> compilationAndClasses =
                context.CompilationProvider.Combine(typeDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndClasses,
                (spc, source) => Execute(source.Item1, source.Item2, spc));
        }

        private static bool IsCandidateClass(SyntaxNode node) 
            => (node is ClassDeclarationSyntax || node is RecordDeclarationSyntax) &&
                (node as TypeDeclarationSyntax)?.AttributeLists.Count > 0 &&
                (node as TypeDeclarationSyntax)?.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)) == true;

        private bool HasAttribute(TypeDeclarationSyntax classDeclaration, string attributeName) {
            foreach (var attributeList in classDeclaration.AttributeLists) {
                foreach (var attribute in attributeList.Attributes) {
                    var name = attribute.Name.ToString();
                    if (name == attributeName || name == attributeName + "Attribute") {
                        return true;
                    }
                }
            }

            return false;
        }

        private void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> types, SourceProductionContext context) {
            if (types.IsDefaultOrEmpty) {
                return;
            }

            var typeDefinitions = new List<PropertyClassDefinition>();
            foreach (var typeDeclaration in types) {
                try {
                    var classDefinition = ProcessClass(compilation, typeDeclaration);
                    if (classDefinition != null) {
                        typeDefinitions.Add(classDefinition);

                        // Generate serialization code for this class.
                        var source = GenerateSerializationCode(classDefinition, GetNamespace(typeDeclaration));
                        context.AddSource($"{classDefinition.Name}.g.cs", SourceText.From(source, Encoding.UTF8));

                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                new DiagnosticDescriptor(
                                    "IMC0004",
                                    "Source Generation Information",
                                    $"Generated source file: {classDefinition.Name}.g.cs with {classDefinition.AllProperties.Count} properties",
                                    "Imcodec.ObjectProperty.CodeGen",
                                    DiagnosticSeverity.Info,
                                    isEnabledByDefault: true),
                                Location.None));
                    }
                    else {
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                new DiagnosticDescriptor(
                                    "IMC0001",
                                    "Class Processing Error",
                                    $"Failed to process class {typeDeclaration.Identifier}",
                                    "Imcodec.ObjectProperty.CodeGen",
                                    DiagnosticSeverity.Error,
                                    isEnabledByDefault: true),
                                Location.None));
                    }
                }
                catch (Exception ex) {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            new DiagnosticDescriptor(
                                "IMC0002",
                                "Server Property Class Generation Error",
                                $"Error processing class {typeDeclaration.Identifier}: {ex.Message}",
                                "Imcodec.ObjectProperty.CodeGen",
                                DiagnosticSeverity.Error,
                                isEnabledByDefault: true),
                            Location.None));
                }
            }

            // Generate the type registry class.
            try {
                var dispatcherSource = WriteDispatcherClass(typeDefinitions.ToArray(), ContainingNamespace);
                context.AddSource($"{TypeRegistryClassName}.g.cs", SourceText.From(dispatcherSource, Encoding.UTF8));
            }
            catch (Exception ex) {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "IMC0003",
                            "Type Registry Generation Error",
                            $"Error generating type registry: {ex.Message}",
                            "Imcodec.ObjectProperty.CodeGen",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        Location.None));
            }
        }

        private string GetNamespace(TypeDeclarationSyntax classDeclaration) {
            SyntaxNode? parent = classDeclaration.Parent;
            while (  parent != null && !(parent is NamespaceDeclarationSyntax) 
                && !(parent is FileScopedNamespaceDeclarationSyntax)) {
                parent = parent.Parent;
            }

            if (parent is NamespaceDeclarationSyntax namespaceDeclaration) {
                return namespaceDeclaration.Name.ToString();
            }

            if (parent is FileScopedNamespaceDeclarationSyntax fileScopedNamespace) {
                return fileScopedNamespace.Name.ToString();
            }

            return string.Empty; 
        }

        private PropertyClassDefinition? ProcessClass(Compilation compilation, TypeDeclarationSyntax classDeclaration) {
            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var className = classDeclaration.Identifier.Text;
            var hash = GetClassHash(classDeclaration);
            var classDefinition = new PropertyClassDefinition(className, hash);

            // Add base classes.
            if (classDeclaration.BaseList != null) {
                foreach (var baseType in classDeclaration.BaseList.Types) {
                    var baseTypeName = baseType.Type.ToString();
                    classDefinition.AddBaseClass(baseTypeName);
                }
            }
            else {
                // Default to PropertyClass if no base type is specified.
                classDefinition.AddBaseClass("PropertyClass");
            }

            // Process properties with AutoProperty attribute.
            int propertyCount = 0;
            foreach (var member in classDeclaration.Members) {
                if (member is PropertyDeclarationSyntax propertyDeclaration) {
                    var propertyDefinition = ProcessProperty(propertyDeclaration, semanticModel);
                    if (propertyDefinition != null) {
                        classDefinition.AllProperties.Add(propertyDefinition);
                        propertyCount++;
                    }
                }
            }

            return classDefinition;
        }

        private uint GetClassHash(TypeDeclarationSyntax classDeclaration) {
            // Look for the GetHash method with a hexadecimal return value.
            foreach (var member in classDeclaration.Members) {
                if (member is MethodDeclarationSyntax methodDeclaration &&
                    methodDeclaration.Identifier.Text == "GetHash" &&
                    methodDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.OverrideKeyword))) {
                    
                    if (methodDeclaration.Body != null) {
                        foreach (var statement in methodDeclaration.Body.Statements) {
                            if (statement is ReturnStatementSyntax returnStmt) {
                                // Try to extract hash value.
                                string expressionText = returnStmt.Expression!.ToString();

                                // Remove "0x" prefix if present.
                                if (expressionText.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) {
                                    expressionText = expressionText.Substring(2);
                                }

                                if (uint.TryParse(expressionText,
                                                System.Globalization.NumberStyles.HexNumber,
                                                null, out uint hashValue)) {
                                    return hashValue;
                                }
                            }
                        }
                    }
                    else if (methodDeclaration.ExpressionBody != null) {
                        // Handle expression-bodied methods: public override uint GetHash() => 0x12345678;
                        string expressionText = methodDeclaration.ExpressionBody.Expression.ToString();

                        // Remove "0x" prefix if present.
                        if (expressionText.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) {
                            expressionText = expressionText.Substring(2);
                        }

                        if (uint.TryParse(expressionText,
                                        System.Globalization.NumberStyles.HexNumber,
                                        null, out uint hashValue)) {
                            return hashValue;
                        }
                    }
                }
            }

            // Default hash value if none found.
            return 0;
        }

        private PropertyDefinition? ProcessProperty(PropertyDeclarationSyntax propertyDeclaration, SemanticModel semanticModel) {
            // Check if the property has the AutoProperty attribute.
            bool hasAutoProperty = false;
            AttributeSyntax? autoPropertyAttribute = null;

            foreach (var attributeList in propertyDeclaration.AttributeLists) {
                foreach (var attribute in attributeList.Attributes) {
                    var attributeName = attribute.Name.ToString();
                    if (   attributeName == AutoPropertyAttributeName 
                        || attributeName == AutoPropertyAttributeName + "Attribute") {
                        hasAutoProperty = true;
                        autoPropertyAttribute = attribute;

                        break;
                    }
                }

                if (hasAutoProperty) {
                    break;
                }
            }

            if (!hasAutoProperty || autoPropertyAttribute?.ArgumentList == null ||
                autoPropertyAttribute.ArgumentList.Arguments.Count < 2) {

                return null;
            }

            uint hash = 0;
            uint flags = 0;

            var hashArg = autoPropertyAttribute.ArgumentList.Arguments[0].Expression.ToString();
            var flagsArg = autoPropertyAttribute.ArgumentList.Arguments[1].Expression.ToString();

            // Handle hexadecimal hash values.
            if (hashArg.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) {
                hashArg = hashArg.Substring(2);
                _ = uint.TryParse(hashArg, System.Globalization.NumberStyles.HexNumber, null, out hash);
            }

            // Parse flags.
            _ = uint.TryParse(flagsArg, out flags);

            // Get property type information.
            var propertyName = propertyDeclaration.Identifier.Text;
            var propertyType = propertyDeclaration.Type.ToString();

            // Check if it's a collection type.
            string container = "";
            if (propertyType.StartsWith("List<") || propertyType.EndsWith("[]")) {
                container = "List";

                // If the property is a collection, grab the internal type.
                if (propertyType.StartsWith("List<")) {
                    // Find the closing angle bracket for the List<T> type.
                    int startIndex = propertyType.IndexOf('<') + 1;
                    int endIndex = propertyType.LastIndexOf('>');
                    propertyType = propertyType.Substring(startIndex, endIndex - startIndex);
                }
                else if (propertyType.EndsWith("[]")) {
                    // Find the closing bracket for the array type.
                    int startIndex = propertyType.IndexOf('[') + 1;
                    int endIndex = propertyType.LastIndexOf(']');
                    propertyType = propertyType.Substring(startIndex, endIndex - startIndex);
                }
            }

            // Check if it's an enum type.
            var propertySymbol = semanticModel.GetDeclaredSymbol(propertyDeclaration);
            var isEnum = propertySymbol?.Type.TypeKind == TypeKind.Enum
                     || (flags & (uint) PropertyFlags.Prop_Enum) != 0;

            // Get enum options if it's an enum.
            var enumOptions = new Dictionary<string, object>();
            if (isEnum && propertySymbol != null) {
                if (propertySymbol.Type is INamedTypeSymbol enumType) {
                    foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>()
                            .Where(m => m.HasConstantValue)) {
                        enumOptions[member.Name] = member.ConstantValue!;
                    }
                }

                // Add "enum " prefix to type name for enum types
                propertyType = "enum " + propertyType;
            }

            // Create property definition.
            var propDef = new PropertyDefinition(
                propertyName,
                propertyType,
                flags,
                container,
                hash,
                enumOptions);
                
            return propDef;
        }

        private string GenerateSerializationCode(PropertyClassDefinition classDefinition, string namespaceName) {
            var sb = new StringBuilder();

            // Add copyright header and auto-generated warning.
            sb.AppendLine(CopyrightHeader);
            sb.AppendLine();
            sb.AppendLine(s_autoGeneratedWarning);
            sb.AppendLine();

            // Enable nullable reference types.
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            // Add usings.
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using Imcodec.Types;");
            sb.AppendLine("using Imcodec.IO;");
            sb.AppendLine("using Imcodec.Math;");
            sb.AppendLine("using Imcodec.ObjectProperty;");
            sb.AppendLine("using Imcodec.ObjectProperty.Bit;");
            sb.AppendLine();

            // Add namespace and partial class declaration.
            var topMostBaseClass = classDefinition.BaseClassNames[0];
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
            sb.AppendLine($"public partial record {classDefinition.Name} : {topMostBaseClass} {{\n");

            // Generate serialization methods.
            sb.Append(PropertyClassSerializationGenerator.GenerateSerializationMethods(classDefinition));

            // Generate versionable methods.
            sb.Append(PropertyClassSerializationGenerator.GenerateVersionableMethods(classDefinition));

            // Generate helper methods.
            sb.Append(PropertyClassSerializationGenerator.GenerateHelperMethods());

            sb.AppendLine("}");

            return sb.ToString();
        }

        private string WriteDispatcherClass(PropertyClassDefinition[] classDefinitions, string containingNamespace) {
            var dispatcherBuilder = new StringBuilder();
            dispatcherBuilder.AppendLine($"{CopyrightHeader}\n");
            dispatcherBuilder.AppendLine($"{s_autoGeneratedWarning}\n");

            dispatcherBuilder.AppendLine("using System;");
            dispatcherBuilder.AppendLine("using System.Collections.Generic;");
            
            dispatcherBuilder.AppendLine($"\nnamespace {containingNamespace};\n");

            dispatcherBuilder.AppendLine($"public partial class {TypeRegistryClassName} : TypeRegistry {{\n");

            // Write the type lookup table constructor.
            dispatcherBuilder.AppendLine($"\tpublic {TypeRegistryClassName}() {{");
            foreach (var classDefinition in classDefinitions) {
                dispatcherBuilder.AppendLine($"\t\tRegisterType({classDefinition.Hash}, typeof({classDefinition.Name}));");
            }
            dispatcherBuilder.AppendLine("\t}\n");

            dispatcherBuilder.AppendLine("}");

            return dispatcherBuilder.ToString();
        }

    }

}