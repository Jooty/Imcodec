using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Imcodec.ObjectProperty.CodeGen.Definitions;

namespace Imcodec.ObjectProperty.CodeGen {

    [Generator]
    public sealed class ServerPropertyClassSourceGenerator : IIncrementalGenerator {
        
        private const string CopyrightHeader = @"/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/";

        private const string ContainingNamespace = "Imcodec.ObjectProperty.TypeCache";
        private const string TypeRegistryClassName = "ServerGeneratedTypeRegistry";
        private static readonly string s_autoGeneratedWarning = $"// <auto-generated"
            + $" by {typeof(ServerPropertyClassSourceGenerator).Assembly.GetName().Name}>";

        private const string PropertyClassAttributeName = "PropertySerializationTargetAttribute";
        private const string AutoPropertyAttributeName = "PropertyField";
        
        private const string LogFilePath = @"C:\Users\Jay\Downloads\imcodec_source_generator.log";

        public void Initialize(IncrementalGeneratorInitializationContext context) {
            InitializeLogFile();

            // Get all class declarations with our target attribute (PropertySerializationTargetAttribute)
            IncrementalValuesProvider<TypeDeclarationSyntax> typeDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsCandidateClass(s),
                    transform: static (ctx, _) => ctx.Node as TypeDeclarationSyntax)
                .Where(type => type != null && HasAttribute(type, PropertyClassAttributeName));

            // Register source output.
            IncrementalValueProvider<(Compilation, ImmutableArray<TypeDeclarationSyntax>)> compilationAndClasses =
                context.CompilationProvider.Combine(typeDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndClasses,
                (spc, source) => Execute(source.Item1, source.Item2, spc));
        }

        private void InitializeLogFile() {
            using (var writer = new StreamWriter(LogFilePath, false)) {
                writer.WriteLine($"=== Imcodec Source Generator Log ===");
                writer.WriteLine($"Started at: {DateTime.Now}");
                writer.WriteLine($"Generator: {typeof(ServerPropertyClassSourceGenerator).FullName}");
                writer.WriteLine($"=================================");
                writer.WriteLine();
            }
        }

        private void LogMessage(string message) {
            using (var writer = new StreamWriter(LogFilePath, true)) {
                writer.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] {message}");
            }
        }

        private static bool IsCandidateClass(SyntaxNode node) {
            return (node is ClassDeclarationSyntax || node is RecordDeclarationSyntax) &&
                (node as TypeDeclarationSyntax)?.AttributeLists.Count > 0 &&
                (node as TypeDeclarationSyntax)?.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)) == true;
        }

        private bool HasAttribute(TypeDeclarationSyntax classDeclaration, string attributeName) {
            LogMessage($"Checking class: {classDeclaration.Identifier} for attribute: {attributeName}");

            foreach (var attributeList in classDeclaration.AttributeLists) {
                foreach (var attribute in attributeList.Attributes) {
                    LogMessage($"Checking attribute: {attribute.Name}");

                    var name = attribute.Name.ToString();
                    if (name == attributeName || 
                        name == attributeName + "Attribute" ||
                        name.EndsWith("." + attributeName) ||
                        name.EndsWith("." + attributeName + "Attribute")) {
                        LogMessage($"Found attribute: {attributeName}");

                        return true;
                    }
                }
            }

            LogMessage($"Class {classDeclaration.Identifier} does not have attribute {attributeName}");

            return false;
        }

        private void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> types, SourceProductionContext context) {
            if (types.IsDefaultOrEmpty) {
                LogMessage("No classes or records found with PropertySerializationTargetAttribute. Source generation skipped.");

                return;
            }

            LogMessage($"Found {types.Length} type(s) with {PropertyClassAttributeName}.");

            var typeDefinitions = new List<PropertyClassDefinition>();
            foreach (var typeDeclaration in types) {
                try {
                    LogMessage($"Processing class: {typeDeclaration.Identifier}");
                    
                    var classDefinition = ProcessClass(compilation, typeDeclaration);
                    if (classDefinition != null) {
                        typeDefinitions.Add(classDefinition);

                        // Generate serialization code for this class.
                        var source = GenerateSerializationCode(classDefinition, GetNamespace(typeDeclaration));
                        context.AddSource($"{classDefinition.Name}.g.cs", SourceText.From(source, Encoding.UTF8));

                        LogMessage($"Generated {classDefinition.Name}.g.cs with {classDefinition.Properties.Count} properties");

                        foreach (var property in classDefinition.Properties) {
                            LogMessage($"  - Property: {property.Name}, Hash: 0x{property.Hash:X8}, Type: {property.CsharpType}, " + 
                                      $"Flags: {property.Flags}, IsVector: {(property.IsVector ? "Yes" : "No")}");
                        }

                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                new DiagnosticDescriptor(
                                    "IMC0004",
                                    "Source Generation Information",
                                    $"Generated source file: {classDefinition.Name}.g.cs with {classDefinition.Properties.Count} properties",
                                    "Imcodec.ObjectProperty.CodeGen",
                                    DiagnosticSeverity.Info,
                                    isEnabledByDefault: true),
                                Location.None));
                    }
                    else {
                        LogMessage($"Class {typeDeclaration.Identifier} was not processed - it may not have valid properties or a proper GetHash() method.");
                    }
                }
                catch (Exception ex) {
                    LogMessage($"ERROR processing class {typeDeclaration.Identifier}: {ex.Message}");
                    LogMessage($"Stack trace: {ex.StackTrace}");

                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            new DiagnosticDescriptor(
                                "IMC0002",
                                "Server Property Class Generation Error",
                                $"Error processing class {typeDeclaration.Identifier}: {ex.Message}",
                                "Imcodec.ObjectProperty.CodeGen",
                                DiagnosticSeverity.Error,
                                isEnabledByDefault: true),
                            Location.None));
                }
            }

            // Generate the type registry class.
            try {
                LogMessage("Generating type registry class");
                var dispatcherSource = WriteDispatcherClass(typeDefinitions.ToArray(), ContainingNamespace);
                context.AddSource($"{TypeRegistryClassName}.g.cs", SourceText.From(dispatcherSource, Encoding.UTF8));
                LogMessage($"Generated {TypeRegistryClassName}.g.cs with {typeDefinitions.Count} registered types");
                
                foreach (var cls in typeDefinitions) {
                    LogMessage($"  - Registered: {cls.Name}, Hash: 0x{cls.Hash:X8}");
                }
            }
            catch (Exception ex) {
                LogMessage($"ERROR generating type registry: {ex.Message}");
                LogMessage($"Stack trace: {ex.StackTrace}");
                
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "IMC0003",
                            "Type Registry Generation Error",
                            $"Error generating type registry: {ex.Message}",
                            "Imcodec.ObjectProperty.CodeGen",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        Location.None));
            }

            LogMessage("Source generation completed.");
        }

        private string GetNamespace(TypeDeclarationSyntax classDeclaration) {
            SyntaxNode? parent = classDeclaration.Parent;
            while (  parent != null && !(parent is NamespaceDeclarationSyntax) 
                && !(parent is FileScopedNamespaceDeclarationSyntax)) {
                parent = parent.Parent;
            }

            if (parent is NamespaceDeclarationSyntax namespaceDeclaration) {
                return namespaceDeclaration.Name.ToString();
            }

            if (parent is FileScopedNamespaceDeclarationSyntax fileScopedNamespace) {
                return fileScopedNamespace.Name.ToString();
            }

            return string.Empty; 
        }

        private PropertyClassDefinition? ProcessClass(Compilation compilation, TypeDeclarationSyntax classDeclaration) {
            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var className = classDeclaration.Identifier.Text;
            
            LogMessage($"Extracting hash for class: {className}");
            var hash = GetClassHash(classDeclaration);
            LogMessage($"Class hash: 0x{hash:X8}");
            
            var classDefinition = new PropertyClassDefinition(className, hash);

            // Add base classes.
            if (classDeclaration.BaseList != null) {
                foreach (var baseType in classDeclaration.BaseList.Types) {
                    var baseTypeName = baseType.Type.ToString();
                    classDefinition.AddBaseClass(baseTypeName);
                    LogMessage($"Added base class: {baseTypeName}");
                }
            }
            else {
                // Default to PropertyClass if no base type is specified.
                classDefinition.AddBaseClass("PropertyClass");
                LogMessage("No base classes specified, defaulting to PropertyClass");
            }

            // Process properties with AutoProperty attribute.
            int propertyCount = 0;
            foreach (var member in classDeclaration.Members) {
                if (member is PropertyDeclarationSyntax propertyDeclaration) {
                    LogMessage($"Examining property: {propertyDeclaration.Identifier.Text}");
                    var propertyDefinition = ProcessProperty(propertyDeclaration, semanticModel);
                    if (propertyDefinition != null) {
                        classDefinition.Properties.Add(propertyDefinition);
                        propertyCount++;
                        LogMessage($"Added property: {propertyDefinition.Name} with hash: 0x{propertyDefinition.Hash:X8}");
                    }
                    else {
                        LogMessage($"Property {propertyDeclaration.Identifier.Text} was not added (missing or invalid AutoProperty attribute)");
                    }
                }
            }
            
            LogMessage($"Processed {propertyCount} properties for class {className}");

            return classDefinition;
        }

        private uint GetClassHash(TypeDeclarationSyntax classDeclaration) {
            // Look for the GetHash method with a hexadecimal return value.
            foreach (var member in classDeclaration.Members) {
                if (member is MethodDeclarationSyntax methodDeclaration &&
                    methodDeclaration.Identifier.Text == "GetHash" &&
                    methodDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.OverrideKeyword))) {
                    
                    LogMessage($"Found GetHash method in {classDeclaration.Identifier.Text}");
                    
                    if (methodDeclaration.Body != null) {
                        foreach (var statement in methodDeclaration.Body.Statements) {
                            if (statement is ReturnStatementSyntax returnStmt) {
                                // Try to extract hash value.
                                string expressionText = returnStmt.Expression!.ToString();
                                LogMessage($"Return expression: {expressionText}");

                                // Remove "0x" prefix if present.
                                if (expressionText.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) {
                                    expressionText = expressionText.Substring(2);
                                    LogMessage($"Stripped 0x prefix, remaining: {expressionText}");
                                }

                                if (uint.TryParse(expressionText,
                                                System.Globalization.NumberStyles.HexNumber,
                                                null, out uint hashValue)) {
                                    LogMessage($"Successfully parsed hash: 0x{hashValue:X8}");
                                    return hashValue;
                                }
                                else {
                                    LogMessage($"Failed to parse hash value from: {expressionText}");
                                }
                            }
                        }
                    }
                    else if (methodDeclaration.ExpressionBody != null) {
                        // Handle expression-bodied methods: public override uint GetHash() => 0x12345678;
                        string expressionText = methodDeclaration.ExpressionBody.Expression.ToString();
                        LogMessage($"Expression-bodied method, expression: {expressionText}");

                        // Remove "0x" prefix if present.
                        if (expressionText.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) {
                            expressionText = expressionText.Substring(2);
                            LogMessage($"Stripped 0x prefix, remaining: {expressionText}");
                        }

                        if (uint.TryParse(expressionText,
                                        System.Globalization.NumberStyles.HexNumber,
                                        null, out uint hashValue)) {
                            LogMessage($"Successfully parsed hash: 0x{hashValue:X8}");
                            return hashValue;
                        }
                        else {
                            LogMessage($"Failed to parse hash value from: {expressionText}");
                        }
                    }
                }
            }

            // Default hash value if none found.
            LogMessage("WARNING: No valid GetHash method found, using default value 0");
            return 0;
        }

        private PropertyDefinition? ProcessProperty(PropertyDeclarationSyntax propertyDeclaration, SemanticModel semanticModel) {
            // Check if the property has the AutoProperty attribute.
            bool hasAutoProperty = false;
            AttributeSyntax? autoPropertyAttribute = null;

            foreach (var attributeList in propertyDeclaration.AttributeLists) {
                foreach (var attribute in attributeList.Attributes) {
                    var attributeName = attribute.Name.ToString();
                    if (attributeName == AutoPropertyAttributeName || attributeName == AutoPropertyAttributeName + "Attribute") {
                        hasAutoProperty = true;
                        autoPropertyAttribute = attribute;
                        LogMessage($"Found AutoProperty attribute on {propertyDeclaration.Identifier.Text}");
                        break;
                    }
                }

                if (hasAutoProperty) {
                    break;
                }
            }

            if (!hasAutoProperty || autoPropertyAttribute?.ArgumentList == null ||
                autoPropertyAttribute.ArgumentList.Arguments.Count < 2) {
                LogMessage($"Property {propertyDeclaration.Identifier.Text} does not have a valid AutoProperty attribute");
                return null;
            }

            uint hash = 0;
            uint flags = 0;

            var hashArg = autoPropertyAttribute.ArgumentList.Arguments[0].Expression.ToString();
            var flagsArg = autoPropertyAttribute.ArgumentList.Arguments[1].Expression.ToString();
            
            LogMessage($"AutoProperty args: hash={hashArg}, flags={flagsArg}");

            // Handle hexadecimal hash values.
            if (hashArg.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) {
                hashArg = hashArg.Substring(2);
                if (uint.TryParse(hashArg, System.Globalization.NumberStyles.HexNumber, null, out hash)) {
                    LogMessage($"Parsed hex hash: 0x{hash:X8}");
                }
                else {
                    LogMessage($"Failed to parse hex hash: {hashArg}");
                }
            }
            else {
                if (uint.TryParse(hashArg, out hash)) {
                    LogMessage($"Parsed decimal hash: {hash} (0x{hash:X8})");
                }
                else {
                    LogMessage($"Failed to parse decimal hash: {hashArg}");
                }
            }

            // Parse flags.
            if (uint.TryParse(flagsArg, out flags)) {
                LogMessage($"Parsed flags: {flags}");
            }
            else {
                LogMessage($"Failed to parse flags: {flagsArg}");
            }

            // Get property type information.
            var propertyName = propertyDeclaration.Identifier.Text;
            var propertyType = propertyDeclaration.Type.ToString();
            LogMessage($"Property {propertyName} has type: {propertyType}");

            // Check if it's a collection type.
            string container = "";

            if (propertyType.StartsWith("List<") || propertyType.EndsWith("[]")) {
                container = "List";
                LogMessage($"Property {propertyName} identified as a collection");
            }

            // Check if it's an enum type
            bool isEnum = false;
            var propertySymbol = semanticModel.GetDeclaredSymbol(propertyDeclaration);
            if (propertySymbol != null) {
                isEnum = propertySymbol.Type.TypeKind == TypeKind.Enum;
                if (isEnum) {
                    LogMessage($"Property {propertyName} identified as an enum");
                }
            }

            // Get enum options if it's an enum
            var enumOptions = new Dictionary<string, object>();
            if (isEnum && propertySymbol != null) {
                var enumType = propertySymbol.Type as INamedTypeSymbol;
                if (enumType != null) {
                    LogMessage($"Processing enum members for {propertyName}");
                    foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>()
                            .Where(m => m.HasConstantValue)) {
                        enumOptions[member.Name] = member.ConstantValue!;
                        LogMessage($"  - Enum value: {member.Name} = {member.ConstantValue}");
                    }
                }

                // Add "enum " prefix to type name for enum types
                propertyType = "enum " + propertyType;
                LogMessage($"Updated property type to: {propertyType}");
            }

            // Create property definition
            var propDef = new PropertyDefinition(
                propertyName,
                propertyType,
                flags,
                container,
                hash,
                enumOptions);
                
            LogMessage($"Created PropertyDefinition for {propertyName}");
            return propDef;
        }

        private string GenerateSerializationCode(PropertyClassDefinition classDefinition, string namespaceName) {
            LogMessage($"Generating serialization code for {classDefinition.Name} in namespace {namespaceName}");
            
            var sb = new StringBuilder();

            // Add copyright header and auto-generated warning.
            sb.AppendLine(CopyrightHeader);
            sb.AppendLine();
            sb.AppendLine(s_autoGeneratedWarning);
            sb.AppendLine();

            // Add usings.
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using Imcodec.Types;");
            sb.AppendLine("using Imcodec.IO;");
            sb.AppendLine("using Imcodec.Math;");
            sb.AppendLine("using Imcodec.ObjectProperty;");
            sb.AppendLine("using Imcodec.ObjectProperty.Bit;");
            sb.AppendLine();

            // Add namespace and partial class declaration.
            var topMostBaseClass = classDefinition.BaseClassNames[0];
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
            sb.AppendLine($"public partial record {classDefinition.Name} : {topMostBaseClass} {{\n");

            // Generate serialization methods.
            sb.Append(PropertyClassSerializationGenerator.GenerateSerializationMethods(classDefinition));
            LogMessage($"Generated serialization methods for {classDefinition.Name}");

            // Generate versionable methods.
            sb.Append(PropertyClassSerializationGenerator.GenerateVersionableMethods(classDefinition));
            LogMessage($"Generated versionable methods for {classDefinition.Name}");

            // Generate helper methods.
            sb.Append(PropertyClassSerializationGenerator.GenerateHelperMethods());
            LogMessage($"Generated helper methods for {classDefinition.Name}");

            sb.AppendLine("}");

            return sb.ToString();
        }

        private string WriteDispatcherClass(PropertyClassDefinition[] classDefinitions, string containingNamespace) {
            LogMessage($"Generating type registry class with {classDefinitions.Length} type(s)");
            
            var dispatcherBuilder = new StringBuilder();
            dispatcherBuilder.AppendLine($"{CopyrightHeader}\n");
            dispatcherBuilder.AppendLine($"{s_autoGeneratedWarning}\n");

            dispatcherBuilder.AppendLine("using System;");
            dispatcherBuilder.AppendLine("using System.Collections.Generic;");
            
            dispatcherBuilder.AppendLine($"\nnamespace {containingNamespace};\n");

            dispatcherBuilder.AppendLine($"public partial class {TypeRegistryClassName} : TypeRegistry {{\n");

            // Write the type lookup table constructor.
            dispatcherBuilder.AppendLine($"\tpublic {TypeRegistryClassName}() {{");
            foreach (var classDefinition in classDefinitions) {
                dispatcherBuilder.AppendLine($"\t\tRegisterType({classDefinition.Hash}, typeof({classDefinition.Name}));");
                LogMessage($"Added registration for {classDefinition.Name} with hash 0x{classDefinition.Hash:X8}");
            }
            dispatcherBuilder.AppendLine("\t}\n");

            dispatcherBuilder.AppendLine("}");

            return dispatcherBuilder.ToString();
        }

    }

}