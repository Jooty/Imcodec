/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/

using System.Text;
using Microsoft.CodeAnalysis;
using Imcodec.ObjectProperty.CodeGen.AST;
using Imcodec.ObjectProperty.CodeGen.JSON;
using System.Linq;
using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis.Text;

namespace Imcodec.ObjectProperty.CodeGen {
    [Generator]
    public sealed class SourceGenerator : ISourceGenerator {

        private const string CopyrightHeader = @"/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/";
        private const string ContainingNamespace = "Imcodec.ObjectProperty";
        private static readonly string s_autoGeneratedWarning = $"// <auto-generated"
         + $" by {typeof(SourceGenerator).Assembly.GetName().Name}>";

        private static int s_diagnosticCounter = 0;

        public void Execute(GeneratorExecutionContext context) {
            try {
                ExecuteCore(context);
            } catch (Exception e) {
                var diagnostic = DiagnosticWriter("Error", e.Message);
                context.ReportDiagnostic(diagnostic);
            }
        }

        private static void ExecuteCore(GeneratorExecutionContext context) {
            var relevantContentFiles = GetRelevantContentFiles(context);
            var additionalTexts = relevantContentFiles as AdditionalText[] ?? relevantContentFiles.ToArray();
            if (!additionalTexts.Any()) {
                var noJsonDiagnostic = DiagnosticWriter("No JSON files found",
                                                  "No JSON files found in the project.");
                context.ReportDiagnostic(noJsonDiagnostic);

                return;
            }

            var file = additionalTexts.First();
            var text = file.GetText(context.CancellationToken);

            if (text.Length <= 0) {
                var noTextDiagnostic = DiagnosticWriter("No text in file",
                                                        "The file has no text.");
                context.ReportDiagnostic(noTextDiagnostic);

                return;
            }

            var contextInput = text.ToString();
            var compilerDump = CompileJsonToCsharp(contextInput);

            if (compilerDump == null) {
                var noDumpDiagnostic = DiagnosticWriter("No dump",
                                                        "The compiler dump is null.");
                context.ReportDiagnostic(noDumpDiagnostic);

                return;
            }

            var classCounter = GenerateClasses(compilerDump, ContainingNamespace, context);
            if (classCounter == 0) {
                var noClassesDiagnostic = DiagnosticWriter("No classes added",
                                                           "No classes were added to the compilation.");
                context.ReportDiagnostic(noClassesDiagnostic);

                return;
            }

            var dispatcherClass = WriteDispatcherClass(compilerDump.ToArray(), ContainingNamespace);
            context.AddSource("TypeCache.g.cs", dispatcherClass);
        }

        private static IEnumerable<AdditionalText> GetRelevantContentFiles(GeneratorExecutionContext context)
            => context.AdditionalFiles.Where(f => f.Path.EndsWith(".json"));

        private static List<PropertyClassDefinition> CompileJsonToCsharp(string contextInput) {
            var jsonCompiler = new JsonToCsharpCompiler();
            return jsonCompiler.Compile(contextInput).ToList();
        }

        private static int GenerateClasses(List<PropertyClassDefinition> compilerDump,
                                    string containingNamespace,
                                    GeneratorExecutionContext context) {
            var classCounter = 0;
            foreach (var classDefinition in compilerDump) {
                var classSource = GenerateClassSource(classDefinition, containingNamespace);
                if (classSource == null) {
                    continue;
                }

                context.AddSource($"{classDefinition.ClassName}.g.cs", classSource);
                classCounter++;
            }
            return classCounter;
        }

        private static string GenerateClassSource(PropertyClassDefinition classDefinition,
                                           string containingNamespace) {
            var jsonCompiler = new JsonToCsharpCompiler();
            return jsonCompiler.WriteClassAsString(classDefinition,
                                                      containingNamespace,
                                                      CopyrightHeader,
                                                      s_autoGeneratedWarning);
        }

        public void Initialize(GeneratorInitializationContext context) { }

        private static string WriteDispatcherClass(PropertyClassDefinition[] classDefinitions,
                                                   string containingNamespace) {
            var dispatcherBuilder = new StringBuilder();
            dispatcherBuilder.AppendLine($"{CopyrightHeader}\n");
            dispatcherBuilder.AppendLine($"{s_autoGeneratedWarning}\n");
            dispatcherBuilder.AppendLine($"namespace {containingNamespace};");

            dispatcherBuilder.AppendLine("public static partial class TypeCache {");
            dispatcherBuilder.AppendLine($"\n\tstatic partial void DispatchInternal(uint hash, ref PropertyClass? propertyClass) {{");
            dispatcherBuilder.AppendLine("\t\tpropertyClass = hash switch {");
            dispatcherBuilder.AppendLine($"{string.Join(",\n",
                classDefinitions.Select(c => $"\t\t\t0x{c.ClassName.GetHashCode():X8} => new {c.ClassName}()"))}");
            dispatcherBuilder.AppendLine("\t\t};");
            dispatcherBuilder.AppendLine("\t}");
            dispatcherBuilder.AppendLine("}");

            return dispatcherBuilder.ToString();
        }

        private static Diagnostic DiagnosticWriter(string title, string message) {
            var descriptor = new DiagnosticDescriptor(
                $"IMC{s_diagnosticCounter++}",
                title,
                message,
                "Imcodec.ObjectProperty.CodeGen",
                DiagnosticSeverity.Info,
                true
            );
            var diagnostic = Diagnostic.Create(descriptor, Location.None);

            return diagnostic;
        }

    }
}
