/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/

using System.Text;
using Microsoft.CodeAnalysis;
using Imcodec.ObjectProperty.CodeGen.Definitions;
using Imcodec.ObjectProperty.CodeGen.JSON;
using System.Linq;
using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis.Text;
using System.Threading;

namespace Imcodec.ObjectProperty.CodeGen {
    [Generator]
    public sealed class SourceGenerator : ISourceGenerator {

        private const string CopyrightHeader = @"/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/";
        private const string ContainingNamespace = "Imcodec.ObjectProperty.TypeCache";
        private const string TypeRegistryClassName = "ClientGeneratedTypeRegistry";
        private static readonly string s_autoGeneratedWarning = $"// <auto-generated"
         + $" by {typeof(SourceGenerator).Assembly.GetName().Name}>";

        private static int s_diagnosticCounter = 0;

        public void Execute(GeneratorExecutionContext context) {
            try {
                ExecuteCore(context);
            }
            catch (Exception e) {
                var diagnostic = DiagnosticWriter("Error", e.Message);
                context.ReportDiagnostic(diagnostic);
            }
        }

        public void Initialize(GeneratorInitializationContext context) { }

        private static void ExecuteCore(GeneratorExecutionContext context) {
            // Get all JSON files in the project.
            var relevantContentFiles = GetRelevantContentFiles(context);
            var additionalTexts = relevantContentFiles as AdditionalText[] ?? relevantContentFiles.ToArray();
            if (!additionalTexts.Any()) {
                var noJsonDiagnostic = DiagnosticWriter("No JSON files found",
                                                  "No JSON files found in the project.");
                context.ReportDiagnostic(noJsonDiagnostic);

                return;
            }
            else if (additionalTexts.Count() > 1) {
                var tooManyJsonDiagnostic = DiagnosticWriter("Too many JSON files found",
                                                  "Too many JSON files found in the project. Only one JSON file is supported.");
                context.ReportDiagnostic(tooManyJsonDiagnostic);

                return;
            }

            // The previous check ensures that there is only one JSON file. We can safely get the first one.
            // Ensure that the text is available and we're able to continue.
            var file = additionalTexts.First();
            var text = file.GetText(context.CancellationToken);
            if (text == null) {
                var noTextDiagnostic = DiagnosticWriter("No text in file", "The file has no text.");
                context.ReportDiagnostic(noTextDiagnostic);

                return;
            }
            if (text.Length <= 0) {
                var noTextDiagnostic = DiagnosticWriter("No text in file", "The file has no text.");
                context.ReportDiagnostic(noTextDiagnostic);

                return;
            }

            // Compile the JSON dump into C# classes.
            // If the compiler dump is null, we can't continue.
            var contextInput = text.ToString();
            var compilerDump = GetAbstractDefinitionsFromJson(contextInput);
            if (compilerDump == null) {
                var noDumpDiagnostic = DiagnosticWriter("No dump", "The compiler dump is null.");
                context.ReportDiagnostic(noDumpDiagnostic);

                return;
            }

            // Generate and add the C# classes to the context.
            var classCounter = GenerateFilesFromAbstractDefinitions(compilerDump, ContainingNamespace, context, context.CancellationToken);
            if (classCounter == 0) {
                var noClassesDiagnostic = DiagnosticWriter("No classes added",
                                                           "No classes were added to the compilation.");
                context.ReportDiagnostic(noClassesDiagnostic);

                return;
            }

            // Select only the PropertyClassDefinitions to generate the dispatcher class.
            var classDefinitions = compilerDump.Where(c => c is PropertyClassDefinition)
                                               .Cast<PropertyClassDefinition>()
                                               .ToArray();
            var dispatcherClass = WriteDispatcherClass(classDefinitions, ContainingNamespace);
            context.AddSource($"{TypeRegistryClassName}.g.cs", dispatcherClass);
        }

        private static IEnumerable<AdditionalText> GetRelevantContentFiles(GeneratorExecutionContext context)
            => context.AdditionalFiles.Where(f => f.Path.EndsWith(".json"));

        private static List<Definition> GetAbstractDefinitionsFromJson(string jsonInput) {
            var jsonCompiler = new JsonToCsharpCompiler();
            return jsonCompiler.Compile(jsonInput).ToList();
        }

        private static int GenerateFilesFromAbstractDefinitions(List<Definition> compilerDump,
                                    string containingNamespace,
                                    GeneratorExecutionContext context,
                                    CancellationToken cancellationToken) {
            var classCounter = 0;
            foreach (var classDefinition in compilerDump) {
                cancellationToken.ThrowIfCancellationRequested();

                var classSource = GetDefinitionAsCsharpString(classDefinition, containingNamespace);
                if (classSource == null) {
                    var noSourceDiagnostic = DiagnosticWriter("No source",
                                                              $"The source for {classDefinition.Name} is null.");
                    context.ReportDiagnostic(noSourceDiagnostic);

                    continue;
                }

                context.AddSource($"{classDefinition.Name}.g.cs", classSource);
                classCounter++;
            }
            return classCounter;
        }

        private static string GetDefinitionAsCsharpString(Definition definition, string containingNamespace) {
            var jsonCompiler = new JsonToCsharpCompiler();

            return definition switch {
                EnumDefinition enumDefinition => jsonCompiler.WriteEnumAsString(enumDefinition, containingNamespace,
                    CopyrightHeader, s_autoGeneratedWarning),
                PropertyClassDefinition classDefinition => jsonCompiler.WriteClassAsString(classDefinition,
                    containingNamespace, CopyrightHeader, s_autoGeneratedWarning),
                _ => throw new Exception("Unknown definition type.")
            };
        }

        private static string WriteDispatcherClass(PropertyClassDefinition[] classDefinitions,
                                                   string containingNamespace) {
            var dispatcherBuilder = new StringBuilder();
            dispatcherBuilder.AppendLine($"{CopyrightHeader}\n");
            dispatcherBuilder.AppendLine($"{s_autoGeneratedWarning}\n");
            dispatcherBuilder.AppendLine($"namespace {containingNamespace};\n");

            dispatcherBuilder.AppendLine($"public partial class {TypeRegistryClassName} : TypeRegistry {{\n");

            // Write the type lookup table.
            dispatcherBuilder.AppendLine($"public {TypeRegistryClassName}() {{");
            foreach (var classDefinition in classDefinitions) {
                dispatcherBuilder.AppendLine($"\t\tRegisterType({classDefinition.Hash}, typeof({classDefinition.Name}));");
            }
            dispatcherBuilder.AppendLine("\t}\n");

            dispatcherBuilder.AppendLine("}");

            return dispatcherBuilder.ToString();
        }

        private static Diagnostic DiagnosticWriter(string title, string message) {
            var descriptor = new DiagnosticDescriptor(
                $"IMC{s_diagnosticCounter++}",
                title,
                message,
                "Imcodec.ObjectProperty.CodeGen",
                DiagnosticSeverity.Info,
                true
            );
            var diagnostic = Diagnostic.Create(descriptor, Location.None);

            return diagnostic;
        }

    }
}
