/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/

using System.Text;
using Microsoft.CodeAnalysis;
using Imcodec.ObjectProperty.CodeGen.Definitions;
using Imcodec.ObjectProperty.CodeGen.JSON;
using System.Linq;
using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis.Text;

namespace Imcodec.ObjectProperty.CodeGen {
    [Generator]
    public sealed class SourceGenerator : ISourceGenerator {

        private const string CopyrightHeader = @"/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/";
        private const string ContainingNamespace = "Imcodec.ObjectProperty";
        private static readonly string s_autoGeneratedWarning = $"// <auto-generated"
         + $" by {typeof(SourceGenerator).Assembly.GetName().Name}>";

        private static int s_diagnosticCounter = 0;

        public void Execute(GeneratorExecutionContext context) {
            try {
                ExecuteCore(context);
            } catch (Exception e) {
                var diagnostic = DiagnosticWriter("Error", e.Message);
                context.ReportDiagnostic(diagnostic);
            }
        }

        private static void ExecuteCore(GeneratorExecutionContext context) {
            // Get all JSON files in the project.
            var relevantContentFiles = GetRelevantContentFiles(context);
            var additionalTexts = relevantContentFiles as AdditionalText[] ?? relevantContentFiles.ToArray();
            if (!additionalTexts.Any()) {
                var noJsonDiagnostic = DiagnosticWriter("No JSON files found",
                                                  "No JSON files found in the project.");
                context.ReportDiagnostic(noJsonDiagnostic);

                return;
            }

            // We only care about the first JSON file.
            var file = additionalTexts.First();
            var text = file.GetText(context.CancellationToken);
            if (text == null) {
                var noTextDiagnostic = DiagnosticWriter("No text in file",
                                                        "The file has no text.");
                context.ReportDiagnostic(noTextDiagnostic);

                return;
            }

            if (text.Length <= 0) {
                var noTextDiagnostic = DiagnosticWriter("No text in file",
                                                        "The file has no text.");
                context.ReportDiagnostic(noTextDiagnostic);

                return;
            }

            // Compile the JSON dump into C# classes.
            // If the compiler dump is null, we can't continue.
            var contextInput = text.ToString();
            var compilerDump = CompileJsonToCsharp(contextInput);
            if (compilerDump == null) {
                var noDumpDiagnostic = DiagnosticWriter("No dump",
                                                        "The compiler dump is null.");
                context.ReportDiagnostic(noDumpDiagnostic);

                return;
            }

            // Generate and add the C# classes to the context.
            var classCounter = GenerateFullFile(compilerDump, ContainingNamespace, context);
            if (classCounter == 0) {
                var noClassesDiagnostic = DiagnosticWriter("No classes added",
                                                           "No classes were added to the compilation.");
                context.ReportDiagnostic(noClassesDiagnostic);

                return;
            }

            // Select only the PropertyClassDefinitions to generate the dispatcher class.
            var classDefinitions = compilerDump.Where(c => c is PropertyClassDefinition)
                                               .Cast<PropertyClassDefinition>()
                                               .ToArray();
            var dispatcherClass = WriteDispatcherClass(classDefinitions, ContainingNamespace);
            context.AddSource("TypeCache.g.cs", dispatcherClass);
        }

        private static IEnumerable<AdditionalText> GetRelevantContentFiles(GeneratorExecutionContext context)
            => context.AdditionalFiles.Where(f => f.Path.EndsWith(".json"));

        private static List<Definition> CompileJsonToCsharp(string contextInput) {
            var jsonCompiler = new JsonToCsharpCompiler();
            return [.. jsonCompiler.Compile(contextInput)];
        }

        private static int GenerateFullFile(List<Definition> compilerDump,
                                    string containingNamespace,
                                    GeneratorExecutionContext context) {
            var classCounter = 0;
            foreach (var classDefinition in compilerDump) {
                var classSource = GetDefinitionAsCsharpString(classDefinition, containingNamespace);
                if (classSource == null) {
                    continue;
                }

                context.AddSource($"{classDefinition.Name}.g.cs", classSource);
                classCounter++;
            }
            return classCounter;
        }

        private static string GetDefinitionAsCsharpString(Definition definition, string containingNamespace) {
            var jsonCompiler = new JsonToCsharpCompiler();

            if (definition is EnumDefinition enumDefinition) {
                return jsonCompiler.WriteEnumAsString(enumDefinition, containingNamespace, CopyrightHeader,
                                                      s_autoGeneratedWarning);
            }
            else if (definition is PropertyClassDefinition classDefinition) {
                return jsonCompiler.WriteClassAsString(classDefinition, containingNamespace, CopyrightHeader,
                                                       s_autoGeneratedWarning);
            }
            else {
                throw new Exception("Unknown definition type.");
            }
        }

        public void Initialize(GeneratorInitializationContext context) { }

        private static string WriteDispatcherClass(PropertyClassDefinition[] classDefinitions,
                                                   string containingNamespace) {
            var dispatcherBuilder = new StringBuilder();
            dispatcherBuilder.AppendLine($"{CopyrightHeader}\n");
            dispatcherBuilder.AppendLine($"{s_autoGeneratedWarning}\n");
            dispatcherBuilder.AppendLine($"namespace {containingNamespace};");

            dispatcherBuilder.AppendLine("public static partial class TypeCache {");
            dispatcherBuilder.AppendLine($"\n\tstatic partial void DispatchInternal(uint hash, ref PropertyClass? propertyClass) {{");
            dispatcherBuilder.AppendLine("\t\tpropertyClass = hash switch {");
            dispatcherBuilder.AppendLine($"{string.Join(",\n",
                classDefinitions.Select(c => $"\t\t\t0x{c.Name!.GetHashCode():X8} => new {c.Name}()"))}");
            dispatcherBuilder.AppendLine("\t\t};");
            dispatcherBuilder.AppendLine("\t}");
            dispatcherBuilder.AppendLine("}");

            return dispatcherBuilder.ToString();
        }

        private static Diagnostic DiagnosticWriter(string title, string message) {
            var descriptor = new DiagnosticDescriptor(
                $"IMC{s_diagnosticCounter++}",
                title,
                message,
                "Imcodec.ObjectProperty.CodeGen",
                DiagnosticSeverity.Info,
                true
            );
            var diagnostic = Diagnostic.Create(descriptor, Location.None);

            return diagnostic;
        }

    }
}
