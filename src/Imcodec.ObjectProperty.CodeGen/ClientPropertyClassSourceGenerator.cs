/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/

using System.Text;
using Microsoft.CodeAnalysis;
using Imcodec.ObjectProperty.CodeGen.Definitions;
using Imcodec.ObjectProperty.CodeGen.JSON;
using System.Linq;
using System.Collections.Generic;
using Microsoft.CodeAnalysis.Text;
using System;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;

namespace Imcodec.ObjectProperty.CodeGen {

    [Generator]
    public sealed class ClientPropertyClassSourceGenerator : IIncrementalGenerator {

        private const string CopyrightHeader = @"/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/";
        private const string ContainingNamespace = "Imcodec.ObjectProperty.TypeCache";
        private const string TypeRegistryClassName = "ClientGeneratedTypeRegistry";
        private static readonly string s_autoGeneratedWarning = $"// <auto-generated"
         + $" by {typeof(ClientPropertyClassSourceGenerator).Assembly.GetName().Name}>";

        private const string PropertyClassAttributeName = "PropertySerializationTarget";

        public void Initialize(IncrementalGeneratorInitializationContext context) {
            // Find all classes with the PropertySerializationTarget attribute (server types).
            var serverTypeProvider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (s, _) => s is TypeDeclarationSyntax syntax && syntax.AttributeLists.Count > 0,
                    transform: (ctx, _) => {
                        var typeSyntax = (TypeDeclarationSyntax) ctx.Node;
                        foreach (var attrList in typeSyntax.AttributeLists) {
                            foreach (var attr in attrList.Attributes) {
                                var attrName = attr.Name.ToString();
                                if (attrName is PropertyClassAttributeName or (PropertyClassAttributeName + "Attribute")) {
                                    return typeSyntax.Identifier.Text;
                                }
                            }
                        }
                        return null;
                    })
                .Where(name => name != null);

            // Collect all server type names.
            var serverTypes = serverTypeProvider.Collect().Select((names, _) => {
                var set = new HashSet<string>();
                foreach (var name in names) {
                    if (name != null) {
                        set.Add(name);
                    }
                }
                return set;
            });

            // Register a pipeline of source generator steps.
            // Find all JSON files from AdditionalFiles.
            IncrementalValuesProvider<AdditionalText> jsonFiles = context.AdditionalTextsProvider
                .Where(file => file.Path.EndsWith(".json"));

            // Load and parse the JSON content
            var definitions = jsonFiles.Select((jsonFile, cancellationToken) => {
                var textContent = jsonFile.GetText(cancellationToken);
                if (textContent == null || textContent.Length <= 0) {
                    return [];
                }

                try {
                    return GetAbstractDefinitionsFromJson(textContent.ToString());
                }
                catch {
                    return [];
                }
            });

            // Combine all definition lists.
            var combinedDefinitions = definitions
                .Collect()
                .Select((lists, _) => lists.SelectMany(list => list).ToList());

            // Combine definitions with server types for filtering.
            var definitionsAndServerTypes = combinedDefinitions.Combine(serverTypes);

            // Generate source code for definitions and add to compilation.
            context.RegisterSourceOutput(definitionsAndServerTypes, (spc, source) => {
                try {
                    var allDefinitions = source.Item1;
                    var serverTypeNames = source.Item2;

                    // Extract property class definitions, excluding those already defined by the server.
                    var propertyClassDefs = allDefinitions
                        .Where(def => def is PropertyClassDefinition)
                        .Cast<PropertyClassDefinition>()
                        .Where(def => !serverTypeNames.Contains(def.Name!))
                        .ToList();

                    SetBaseClasses(ref propertyClassDefs);
                    RemoveDuplicatePropertiesFromClasses(ref propertyClassDefs);

                    // Extract enum definitions.
                    var enumDefs = allDefinitions
                        .Where(def => def is EnumDefinition)
                        .Cast<EnumDefinition>()
                        .ToList();

                    CombineDuplicateEnumOptions(ref enumDefs);

                    // Generate source code for each definition.
                    foreach (var definition in propertyClassDefs.Cast<Definition>().Concat(enumDefs)) {
                        var definitionSource = GetDefinitionAsCsharpString(definition, ContainingNamespace);
                        if (definitionSource != null) {
                            spc.AddSource($"{definition.Name}.g.cs", definitionSource);
                        }
                    }

                    // Generate dispatcher class.
                    var dispatcherClassSource = WriteDispatcherClass(propertyClassDefs.ToArray(), ContainingNamespace);
                    spc.AddSource($"{TypeRegistryClassName}.g.cs", dispatcherClassSource);
                }
                catch (Exception ex) {
                    spc.ReportDiagnostic(DiagnosticWriter("Error in source generation", ex.Message));
                }
            });
        }

        private static void SetBaseClasses(ref List<PropertyClassDefinition> classDefinitions) {
            foreach (var classDefinition in classDefinitions) {
                if (classDefinition.BaseClassNames.Count == 0) {
                    throw new Exception($"Class \"{classDefinition.Name}\" has no base class.");
                }

                // Find each of the base classes in the list of class definitions.
                // Our integrity check has a -1 because the base class is always
                // 'PropertyClass', which is always defined.
                var baseClasses = classDefinitions
                    .Where(c => classDefinition.BaseClassNames.Contains(c.Name!))
                    .ToList();
                if (baseClasses.Count != classDefinition.BaseClassNames.Count - 1) {
                    throw new Exception($"Class \"{classDefinition.Name}\" has a base class that was not found.");
                }

                classDefinition.BaseClasses = baseClasses;
            }
        }

        private static void RemoveDuplicatePropertiesFromClasses(ref List<PropertyClassDefinition> classDefinitions) {
            // Each PropertyClassDefinition has a number of parent classes. We want to remove the properties
            // that are duplicated in the parent classes. If the definition only inherits from PropertyClass, we
            // don't need to do anything.
            foreach (var classDefinition in classDefinitions) {
                classDefinition.ExclusiveProperties = [.. classDefinition.AllProperties];
                
                // If the class only has one base class, it derives directly from PropertyClass
                // and has no duplicate properties to remove.
                if (classDefinition.BaseClasses.Count == 0) {
                    continue;
                }

                // Set the exclusive properties to be those that are not in the base classes.
                foreach (var baseclass in classDefinition.BaseClasses) {
                    foreach (var property in baseclass.AllProperties) {
                        classDefinition.ExclusiveProperties.RemoveAll(p => p.Hash == property.Hash);
                    }
                }
            }
        }

        private static void CombineDuplicateEnumOptions(ref List<EnumDefinition> enumDefinitions) {
            // Combine duplicate enum options into a single enum definition.
            // This is useful for enums that are defined in multiple classes.
            var combinedEnums = new List<EnumDefinition>();
            foreach (var enumDefinition in enumDefinitions) {
                var existingEnum = combinedEnums.FirstOrDefault(e => e.Name == enumDefinition.Name);
                if (existingEnum == null) {
                    combinedEnums.Add(enumDefinition);
                    continue;
                }

                foreach (var option in enumDefinition.Options) {
                    // If the option already exists, we don't need to add it.
                    if (existingEnum.Options.ContainsKey(option.Key)) {
                        continue;
                    }

                    existingEnum.Options.Add(option.Key, option.Value);
                }
            }

            enumDefinitions = combinedEnums;
        }

        private static List<Definition> GetAbstractDefinitionsFromJson(string jsonInput) {
            var jsonCompiler = new JsonToCsharpCompiler();

            return [.. jsonCompiler.Compile(jsonInput)];
        }

        private static string GetDefinitionAsCsharpString(Definition definition, string containingNamespace) {
            var jsonCompiler = new JsonToCsharpCompiler();

            return definition switch {
                EnumDefinition enumDefinition => jsonCompiler.WriteEnumAsString(enumDefinition, containingNamespace,
                    CopyrightHeader, s_autoGeneratedWarning),
                PropertyClassDefinition classDefinition => WriteClassAsStringWithSerialization(classDefinition,
                    containingNamespace, CopyrightHeader, s_autoGeneratedWarning),
                _ => throw new Exception("Unknown definition type.")
            };
        }

        private static string WriteClassAsStringWithSerialization(PropertyClassDefinition classDefinition,
                                                                string containingNamespace,
                                                                string copyrightHeader,
                                                                string autoGeneratedWarning) {
            var jsonCompiler = new JsonToCsharpCompiler();

            // Get the basic class definition without serialization methods.
            var basicClassDef = jsonCompiler.WriteClassAsString(classDefinition, containingNamespace,
                copyrightHeader, autoGeneratedWarning);

            // Insert our generated serialization methods before the closing brace.
            var lastBraceIndex = basicClassDef.LastIndexOf('}');
            if (lastBraceIndex < 0) {
                return basicClassDef; // Safety check.
            }

            var beforeBrace = basicClassDef.Substring(0, lastBraceIndex);
            var serializationMethods = PropertyClassSerializationGenerator.GenerateSerializationMethods(classDefinition);
            var versionableMethods = PropertyClassSerializationGenerator.GenerateVersionableMethods(classDefinition);
            var helperMethods = PropertyClassSerializationGenerator.GenerateHelperMethods();

            return beforeBrace + serializationMethods + versionableMethods + helperMethods + "}";
        }

        private static string WriteDispatcherClass(PropertyClassDefinition[] classDefinitions,
                                                   string containingNamespace) {
            var dispatcherBuilder = new StringBuilder();
            dispatcherBuilder.AppendLine($"{CopyrightHeader}\n");
            dispatcherBuilder.AppendLine($"{s_autoGeneratedWarning}\n");
            dispatcherBuilder.AppendLine($"namespace {containingNamespace};\n");

            dispatcherBuilder.AppendLine($"public partial class {TypeRegistryClassName} : TypeRegistry {{\n");

            // Write the type lookup table.
            dispatcherBuilder.AppendLine($"\tpublic {TypeRegistryClassName}() {{");
            foreach (var classDefinition in classDefinitions) {
                dispatcherBuilder.AppendLine($"\t\tRegisterType({classDefinition.Hash}, typeof({classDefinition.Name}));");
            }
            dispatcherBuilder.AppendLine("\t}\n");

            dispatcherBuilder.AppendLine("}");

            return dispatcherBuilder.ToString();
        }

        private static Diagnostic DiagnosticWriter(string title, string message) {
            var descriptor = new DiagnosticDescriptor(
                $"IMC0001",
                title,
                message,
                "Imcodec.ObjectProperty.CodeGen",
                DiagnosticSeverity.Error,
                true
            );

            return Diagnostic.Create(descriptor, Location.None);
        }

    }

}