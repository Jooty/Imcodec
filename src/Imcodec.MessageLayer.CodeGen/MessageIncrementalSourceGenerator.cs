/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.Diagnostics;
using Imcodec.MessageLayer.CodeGen.Definitions;

namespace Imcodec.MessageLayer.CodeGen;

[Generator]
public class MessageIncrementalSourceGenerator : IIncrementalGenerator {

    private const string DEFAULT_OUTPUT_NAMESPACE = "Imcodec.MessageLayer.Generated";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        IncrementalValuesProvider<AdditionalText> wadFiles = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".xml", StringComparison.OrdinalIgnoreCase));

        context.RegisterSourceOutput(wadFiles.Collect(),
            (spc, wadFileCollection) => Execute(spc, wadFileCollection));
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<AdditionalText> xmlFiles) {
        if (xmlFiles.IsEmpty) {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "IMC001",
                    "No XML files found",
                    "No XML files found in the project",
                    "Imcodec.MessageLayer.CodeGen",
                    DiagnosticSeverity.Warning,
                    isEnabledByDefault: true),
                Location.None));

            return;
        }

        try {
            // Generate code for each protocol and add it to the compilation.
            foreach (var xmlFile in xmlFiles) {
                var protocol = XmlMessageReader.ExtractProtocolDefinition(xmlFile, context);
                var sourceText = GenerateProtocolSourceText(protocol, DEFAULT_OUTPUT_NAMESPACE);

                context.AddSource($"{protocol.ClassName}.g.cs", sourceText);
            }
        }
        catch (Exception ex) {
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    "IMC004",
                    "Error generating message protocol code",
                    $"An error occurred while generating message protocol code: {ex.Message} | {ex.StackTrace}",
                    "Imcodec.MessageLayer.CodeGen",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None);

            context.ReportDiagnostic(diagnostic);
        }
    }

    private static SourceText GenerateProtocolSourceText(ProtocolDefinition protocol, string outputNamespace) {
        var sb = new StringBuilder();

        // Add copyright header and auto-generated comment.
        sb.AppendLine(@"/*
BSD 3-Clause License

Copyright (c) 2024, Jooty

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.
*/");
        sb.AppendLine();
        sb.AppendLine($"// <auto-generated by Imcodec.MessageLayer.CodeGen>");
        sb.AppendLine();

        // Add using statements.
        sb.AppendLine("using System;");
        sb.AppendLine("using Imcodec.IO;");
        sb.AppendLine("using Imcodec.MessageLayer;");
        sb.AppendLine();

        // Add namespace declaration.
        sb.AppendLine($"namespace {outputNamespace};\n");

        // Add protocol class.
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// {FormatSummary(protocol.ProtocolDescription)}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public sealed class {protocol.ClassName} : MessageProtocol {{\n");

        // Add protocol properties.
        sb.AppendLine($"    /// <inheritdoc/>");
        sb.AppendLine($"    public override byte ServiceId => {protocol.ServiceId};");
        sb.AppendLine();
        sb.AppendLine($"    /// <inheritdoc/>");
        sb.AppendLine($"    public override string ProtocolType => \"{protocol.ProtocolType}\";");
        sb.AppendLine();
        sb.AppendLine($"    /// <inheritdoc/>");
        sb.AppendLine($"    public override string ProtocolDescription => \"{protocol.ProtocolDescription}\";");
        sb.AppendLine();
        sb.AppendLine($"    /// <inheritdoc/>");
        sb.AppendLine($"    public override int ProtocolVersion => {protocol.ProtocolVersion};");
        sb.AppendLine();

        var messageDefinitions = protocol.Messages
            .GroupBy(static m => m.Name)
            .Select(static g => g.First())
            .ToList();

        // Write protocol dispatcher method.
        sb.AppendLine(WriteProtocolDispatcherMethod(messageDefinitions));

        // Add message classes. Group them by name and select the first one to avoid duplicates.
        foreach (var message in messageDefinitions) {

            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// {FormatSummary(message.Description ?? message.Name)}");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public sealed class {message.Name} : IMessage {{\n");

            // Add message properties.
            sb.AppendLine($"        /// <inheritdoc/>");
            sb.AppendLine($"        public byte MessageOrder => {message.MessageOrder};");
            sb.AppendLine();
            sb.AppendLine($"        /// <inheritdoc/>");
            sb.AppendLine($"        public byte ServiceId => {message.ServiceId};");
            sb.AppendLine();
            sb.AppendLine($"        /// <inheritdoc/>");
            sb.AppendLine($"        public byte AccessLevel => {message.AccessLevel};");
            sb.AppendLine();

            // Add message fields.
            foreach (var field in message.Fields) {
                sb.AppendLine($"        public {field.CSharpType} {field.Name} {{ get; set; }}");
            }

            // Add message encoder.
            sb.AppendLine();
            sb.AppendLine($"        /// <inheritdoc/>");
            sb.AppendLine(WriteEncodeMethod(message));

            // Add message decoder.
            sb.AppendLine($"        /// <inheritdoc/>");
            sb.AppendLine(WriteDecodeMethod(message));

            // Close message class.
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // Close protocol class and namespace.
        sb.AppendLine("}");

        return SourceText.From(sb.ToString(), Encoding.UTF8);
    }

    private static string WriteProtocolDispatcherMethod(List<MessageDefinition> messageDefinitions) {
        // Write a dispatcher method. It's a switch statement that calls 
        // the appropriate message handler based on the message type.
        var sb = new StringBuilder()
            .AppendLine($"    /// <inheritdoc/>")
            .AppendLine($"    internal override IMessage Dispatch(byte messageId) {{")
            .AppendLine($"        switch (messageId) {{");

        foreach (var message in messageDefinitions) {
            _ = sb.AppendLine($"            case {message.MessageOrder}: return new {message.Name}();");
        }

        return sb
            .AppendLine($"            default: throw new NotSupportedException($\"Message ID {{messageId}} is not supported.\");")
            .AppendLine($"        }}")
            .AppendLine($"    }}")
            .ToString();
    }

    private static string WriteEncodeMethod(MessageDefinition message) {
        var sb = new StringBuilder();

        sb.AppendLine($"        public void Encode(BitWriter writer) {{");

        foreach (var field in message.Fields) {
            var writeMethod = MapTypeToWriteMethod(field.SerializedType);
            sb.AppendLine($"            writer.{writeMethod}(this.{field.Name});");
        }

        sb.AppendLine("        }");

        return sb.ToString();
    }

    private static string WriteDecodeMethod(MessageDefinition message) {
        var sb = new StringBuilder();

        sb.AppendLine($"        public void Decode(BitReader reader) {{");

        foreach (var field in message.Fields) {
            var readMethod = MapTypeToReadMethod(field.SerializedType);
            sb.AppendLine($"            this.{field.Name} = reader.{readMethod}();");
        }

        sb.AppendLine("        }");

        return sb.ToString();
    }

    private static string MapTypeToWriteMethod(string serializedType) {
        return serializedType switch {
            "BYT" => "WriteInt8",
            "BOOL" => "WriteUInt8",
            "UBYT" => "WriteUInt8",
            "UBYTE" => "WriteUInt8",
            "SHRT" => "WriteInt16",
            "USHRT" => "WriteUInt16",
            "USHORT" => "WriteUInt16",
            "INT" => "WriteInt32",
            "UINT" => "WriteUInt32",
            "STR" => "WriteString",
            "WSTR" => "WriteWString",
            "FLT" => "WriteFloat",
            "DBL" => "WriteDouble",
            "GID" => "WriteUInt64",
            _ => throw new NotSupportedException($"Unsupported serialized type: {serializedType}")
        };
    }

    private static string MapTypeToReadMethod(string serializedType) {
        return serializedType switch {
            "BYT" => "ReadInt8",
            "BOOL" => "ReadUInt8",
            "UBYT" => "ReadUInt8",
            "UBYTE" => "ReadUInt8",
            "SHRT" => "ReadInt16",
            "USHRT" => "ReadUInt16",
            "USHORT" => "ReadUInt16",
            "INT" => "ReadInt32",
            "UINT" => "ReadUInt32",
            "STR" => "ReadString",
            "WSTR" => "ReadWString",
            "FLT" => "ReadFloat",
            "DBL" => "ReadDouble",
            "GID" => "ReadUInt64",
            _ => throw new NotSupportedException($"Unsupported serialized type: {serializedType}")
        };
    }

    private static string FormatSummary(string description) {
        if (string.IsNullOrEmpty(description))
            return string.Empty;

        description = description.Trim();

        // Replace multiple consecutive whitespace characters with a single space.
        description = System.Text.RegularExpressions.Regex.Replace(description, @"\s+", " ");

        // Escape XML special characters.
        description = description
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;")
            .Replace("\"", "&quot;")
            .Replace("'", "&apos;");

        return description;
    }

}